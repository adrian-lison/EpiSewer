% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_lazy.R
\name{tbp}
\alias{tbp}
\title{Lazy-execute a function once all data and assumptions are provided}
\usage{
tbp(
  f_name,
  f_expr,
  required_data = c(),
  required_assumptions = c(),
  modeldata = NULL,
  calling_env = rlang::caller_env()
)
}
\arguments{
\item{f_name}{Name of the "functions" that will be executed once everything
is provided.}

\item{f_expr}{Expression with arbitrary R code in which attributes are
assigned to \code{modeldata.}}

\item{required_data}{A character vector with the names of required data.
Different options for one item can be provided using "|" as a separator.
EpiSewer will then check if at least one of the options is present.}

\item{required_assumptions}{A character vector with the names of required
assumptions. Different options for one item can be provided using "|" as a
separator. EpiSewer will then check if at least one of the options is
present.}

\item{modeldata}{Modeldata object in the calling function.}

\item{calling_env}{Calling environment, should be \code{rlang::caller_env()}.}
}
\description{
Lazy-execute a function once all data and assumptions are provided
}
\details{
The difference between \code{tbp} (to be provided) and \code{tbc} (to be
computed) is that \code{tbp} is for promises based on data and assumptions, and
\code{tbc} is for promises based on internal modeldata variables (typically in
\code{.metainfo}). This means that there can also be cascades: once a \code{tbp} is
resolved, this may lead to an update of some metainformation, such that a
\code{tbc} can be resolved in the next update.
}
